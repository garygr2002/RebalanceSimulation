package com.garygregg.rebalance.simulation.simulation;

import org.jetbrains.annotations.NotNull;

import java.util.Objects;

class Pair<FirstType, SecondType> {

    // The first of the pair
    private final FirstType first;

    // The second of the pair
    private final SecondType second;

    /**
     * Constructs a pair from its constituents.
     *
     * @param first  The first of the pair
     * @param second The second of the pair
     */
    public Pair(FirstType first, SecondType second) {

        // Set the member variables.
        this.first = first;
        this.second = second;
    }

    /**
     * Constructs a pair from another pair of the same type.
     *
     * @param pair Another pair of the same type
     */
    @SuppressWarnings("unused")
    public Pair(@NotNull Pair<? extends FirstType,
            ? extends SecondType> pair) {
        this(pair.getFirst(), pair.getSecond());
    }

    /**
     * Combines elements in a standardized way.
     *
     * @param first  The first element
     * @param second The second element
     * @return The elements combined in a standardized way
     */
    public static <T> @NotNull String combine(T first, T second) {
        return String.format("<%s><%s>", process(first), process(second));
    }

    /**
     * Compares two pairs.
     *
     * @param pair1 The first pair
     * @param pair2 The second pair
     * @param <S>   An arbitrary comparable type
     * @param <T>   An arbitrary comparable type
     * @return Negative if the first value is less than the second, zero if the
     * values are equal, positive if the first value is greater than the second
     */
    @SuppressWarnings("unused")
    protected static <S extends Comparable<S>, T extends Comparable<T>>
    int compare(@NotNull Pair<? extends S, ? extends T> pair1,
                @NotNull Pair<S, ? extends T> pair2) {

        // Compare the first element of the two pairs. Are they equal?
        int result = compare(pair1.getFirst(), pair2.getFirst());
        if (0 == result) {

            /*
             * The first elements of the two pairs are equal. Compare the
             * second elements.
             */
            result = compare(pair1.getSecond(), pair2.getSecond());
        }

        // Return the result.
        return result;
    }

    /**
     * Compares two values, taking into account the possibility of either being
     * null
     *
     * @param first  The first value
     * @param second The second value
     * @param <T>    Any type that extends Comparable
     * @return Negative if the first value is less than the second, zero if the
     * values are equal, positive if the first value is greater than the second
     */
    protected static <T extends Comparable<T>> int compare(T first, T second) {

        // Declare the result. Is the first value null?
        int result;
        if (null == first) {

            // The first value is null. Nulls come before non-nulls.
            result = (null == second) ? 0 : Integer.MIN_VALUE;
        }

        // The first value is not null.
        else {

            /*
             * First comes before second if second is null. Otherwise, use the
             * native comparator to compare the two values.
             */
            result = (null == second) ? Integer.MAX_VALUE :
                    first.compareTo(second);
        }

        // Return the result.
        return result;
    }

    /**
     * Processes null arguments for {@code combine}.
     *
     * @param argument An argument to {@code combine}
     * @return A string representation of the argument
     */
    private static @NotNull String process(Object argument) {
        return (null == argument) ? "" : argument.toString();
    }

    @Override
    public boolean equals(Object object) {

        // This method was auto-generated by IntelliJ.
        if (this == object) return true;
        if (!(object instanceof Pair)) return false;

        /*
         * More code auto-generated by IntelliJ, separated from the
         * previous for readability.
         */
        final Pair<?, ?> pair = (Pair<?, ?>) object;
        return Objects.equals(getFirst(), pair.getFirst()) &&
                Objects.equals(getSecond(), pair.getSecond());
    }

    /**
     * Gets the first of the pair.
     *
     * @return Gets the second of the pair
     */
    public FirstType getFirst() {
        return first;
    }

    /**
     * Gets the second of the pair.
     *
     * @return The second of the pair
     */
    public SecondType getSecond() {
        return second;
    }

    @Override
    public int hashCode() {

        // This method was auto-generated by IntelliJ.
        return Objects.hash(getFirst(), getSecond());
    }

    @Override
    public String toString() {
        return combine(getFirst(), getSecond());
    }
}
